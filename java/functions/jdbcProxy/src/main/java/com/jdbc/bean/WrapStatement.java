package com.jdbc.bean;


import io.netty.channel.ChannelHandlerContext;

import java.sql.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

import static com.handler.IOHandler.OK;
import static com.handler.IOHandler.writeShortStr;

public class WrapStatement implements AutoCloseable {

    final AtomicInteger COUNTER = new AtomicInteger(1);

    final WrapConnect wrapConnect;
    final String id;
    final String user;
    long timestamp;

    private Statement statement;

    ConcurrentMap<String, WrapResultSet> rsMap = new ConcurrentHashMap<>(1);

     WrapStatement(WrapConnect wrapConnect, String id, String user) {
        this.wrapConnect = wrapConnect;
        this.id = id;
        this.user = user;
        this.timestamp = System.currentTimeMillis();
    }

    public WrapStatement(WrapConnect wrapConnect, String id, String user, Statement statement) {
        this(wrapConnect, id, user);
        this.statement = statement;
    }

    public void updateTime() {
        timestamp = System.currentTimeMillis();
        wrapConnect.updateTime(timestamp);
    }

    public String getUser() {
        return user;
    }

    public WrapConnect getWrapConnect() {
        return wrapConnect;
    }

    public void getResultSet(ChannelHandlerContext out) throws SQLException {
        ResultSet rs = this.statement.getResultSet();
        String rsId = this.id + COUNTER.incrementAndGet();
        WrapResultSet wrs = new WrapResultSet(this, rsId, rs);
        rsMap.put(rsId, wrs);
        out.write(writeShortStr(OK, rsId));
        wrs.getMetaData(out);
        wrs.next(true, out);
    }

    public WrapResultSet getResultSet(String resultSetId) {
        return rsMap.get(resultSetId);
    }

    public void executeQuery(String sql, ChannelHandlerContext out) throws SQLException {
        ResultSet rs = this.statement.executeQuery(sql);
        String rsId = this.id + COUNTER.incrementAndGet();
        WrapResultSet wrs = new WrapResultSet(this, rsId, rs);
        rsMap.put(rsId, wrs);
        out.write(writeShortStr(OK, rsId));
        wrs.getMetaData(out);
        wrs.next(true, out);
    }

    public int executeUpdate(String sql) throws SQLException {
        return this.statement.executeUpdate(sql);
    }

    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return this.statement.executeUpdate(sql, columnIndexes);
    }

    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return this.statement.executeUpdate(sql, columnNames);
    }

    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return this.statement.executeUpdate(sql, autoGeneratedKeys);
    }

    public boolean execute(String sql) throws SQLException {
        return this.statement.execute(sql);
    }

    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return this.statement.execute(sql, autoGeneratedKeys);
    }

    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return this.statement.execute(sql, columnIndexes);
    }

    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return this.statement.execute(sql, columnNames);
    }

    public void getGeneratedKeys(ChannelHandlerContext out) throws SQLException {
        ResultSet rs = this.statement.getGeneratedKeys();
        String rsId = this.id + COUNTER.incrementAndGet();
        WrapResultSet wrs = new WrapResultSet(this, rsId, rs);
        rsMap.put(rsId, wrs);
        out.write(writeShortStr(OK, rsId));
        wrs.getMetaData(out);
        wrs.next(true, out);
    }

    public int[] executeBatch(String[] sqls) throws SQLException {
        if (sqls == null || sqls.length == 0) throw new SQLException("batch sql is null or empty");
        for (String sql : sqls) {
            this.statement.addBatch(sql);
        }
        return this.statement.executeBatch();
    }

    public void setFetchDirection(int direction) throws SQLException {
        this.statement.setFetchDirection(direction);
    }

    int getFetchSize() throws SQLException {
        return this.statement.getFetchSize();
    }

    public void setFetchSize(int rows) throws SQLException {
        this.statement.setFetchSize(rows);
    }


    @Override
    public void close() {
        rsMap.values().forEach(WrapResultSet::close);
        rsMap.clear();
        try {
            if (statement != null) statement.close();
            wrapConnect.stmtMap.remove(id);
        } catch (SQLException ignored) {
        }

    }
}
