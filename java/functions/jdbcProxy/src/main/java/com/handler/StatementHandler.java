package com.handler;

import com.jdbc.bean.DbAuth;
import com.jdbc.bean.SqlInfo;
import com.jdbc.bean.WrapConnect;
import com.jdbc.bean.WrapStatement;
import com.jdbc.sql.parser.SQLParserUtils;
import com.jdbc.sql.parser.SQLStatementParser;
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;

import java.sql.SQLException;
import java.util.List;

import static com.handler.IOHandler.*;

public class StatementHandler {

    public static void handler(WrapStatement statement, ByteBuf src, ChannelHandlerContext out)
            throws SQLException {
        String mName = IOHandler.readByteLen(src);
        if ("executeQuery".equals(mName)) {
            String sql = readIntLen(src);
            executeAuth(statement.getWrapConnect(), sql);
            statement.executeQuery(sql, out);
        } else if ("executeUpdate".equals(mName)) {
            short pc = src.readUnsignedByte();
            String sql = readIntLen(src);
            executeAuth(statement.getWrapConnect(), sql);
            int count;
            if (1 == pc) count = statement.executeUpdate(sql);
            else {
                int arrSize = src.readUnsignedShort();
                short type = src.readUnsignedByte();
                if (0 == arrSize) {
                    if (0 != type) throw new SQLException("executeUpdate[autoGeneratedKeys] type[" +
                            type + "] error");
                    count = statement.executeUpdate(sql, src.readInt());
                } else {
                    if (0 == type) {
                        int[] columnIndexes = readInt(arrSize, src);
                        count = statement.executeUpdate(sql, columnIndexes);
                    } else if (1 == type) {
                        String[] columnNames = readShortLen(arrSize, src);
                        count = statement.executeUpdate(sql, columnNames);
                    } else throw new SQLException("executeUpdate[array] type[" + type + "] error");
                }
            }
            out.write(writeCmdInt(OK, count));
        } else if ("execute".equals(mName)) {
            short pc = src.readUnsignedByte();
            String sql = readIntLen(src);
            executeAuth(statement.getWrapConnect(), sql);
            boolean bool;
            if (1 == pc) bool = statement.execute(sql);
            else {
                int arrSize = src.readUnsignedShort();
                short type = src.readUnsignedByte();
                if (0 == arrSize) {
                    if (0 != type) throw new SQLException("execute[autoGeneratedKeys] type[" + type + "] error");
                    bool = statement.execute(sql, src.readInt());
                } else {
                    if (0 == type) {
                        int[] columnIndexes = readInt(arrSize, src);
                        bool = statement.execute(sql, columnIndexes);
                    } else if (1 == type) {
                        String[] columnNames = readShortLen(arrSize, src);
                        bool = statement.execute(sql, columnNames);
                    } else throw new SQLException("executeUpdate[array] type[" + type + "] error");
                }
            }
            out.write(writeCmdShortStr(OK, bool ? "true" : "false"));
        } else if ("getGeneratedKeys".equals(mName)) {
            statement.getGeneratedKeys(out);
        } else if ("executeBatch".equals(mName)) {
            int arrSize = src.readUnsignedShort();
            short type = src.readUnsignedByte();
            if (1 != type) throw new SQLException("executeBatch param type[" + type + "] error");
            int[] code = statement.executeBatch(readIntLen(arrSize, src));
            out.write(writeCmdInt(OK, code));
        } else if ("setFetchDirection".equals(mName)) {
            statement.setFetchDirection(src.readInt());
            out.write(writeCmd(OK));
        } else if ("setFetchSize".equals(mName)) {
            statement.setFetchSize(src.readInt());
            out.write(writeCmd(OK));
        } else if ("getResultSet".equals(mName)) {
            statement.getResultSet(out);
        } else if ("close".equals(mName)) {
            statement.close();
        } else throw new SQLException("statementMethod[" + mName + "] is not support");
    }

    private static void executeAuth(WrapConnect wrapConnect, String sql) throws SQLException {
        String uk = wrapConnect.getDbKey() + wrapConnect.getUser();
        String dbName = wrapConnect.getDbName();
        SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, wrapConnect.getDbTypeLower());
        parser.setDefaultDbName(dbName);
        parser.setConn(wrapConnect.getDbConnect());
        List<SqlInfo> sqlInfoList = parser.parseToSQLInfo();
        for (SqlInfo sqlInfo : sqlInfoList) {
            DbAuth.authSql(uk, dbName, sqlInfo);
        }
    }
}
